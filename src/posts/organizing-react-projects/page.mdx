import { FolderView } from "@/features/directory/molecules/folder-view";
import * as folders from "./folders";
import { SearchBar, SearchContext } from "@/molecules/search-bar";

If you've worked in a modern React project before, then you've probably seen
something like this:

<FolderView directory={folders.basicProject} />

Where files are split up across folders depending on what type of code lives
inside them. Components live with other components, hooks live with other hooks,
etc.

For a simple project like the one outlined above, this tends to work fine. But
as your codebase scales, you end up with _low feature cohesion_. Making changes
to one area of your app requires editing multiple files scattered far and wide
across different directories.

To see this in action, lets take a look at a project with a bit more complexity:
**a messaging app**.

<FolderView directory={folders.messagingAppFirstIteration} />

I mentioned that this way of building leads to low feature cohesion, and now we
can start to see why. If you want to overhaul messages, you may need to access
components, hooks, contexts, and types. This code lives in separate files &
folders, with the only indication that they are related being that:

1. they all have _message_ somewhere in their name
2. they likely import from each other.

So what should we do?

Lets make a new rule: if a feature has different types of code that previously
would have been spread across multiple folders, we create a dedicated folder for
that feature. So for example, all the code for messages would now live in
`üìÅ/features/messages`

Lets try this, and see how things look.

<FolderView directory={folders.messagingAppSecondIteration} />

This feels much better. Now when you want to make changes to messages, all of
the code is in one place: `üìÅ/features/messages`

So is that it? Are we done?

We could be. This pattern can take you far. Keeping code for related features
close together will make things much easier to manage as you scale your app.

But I think we can do even better.

Lets take a closer look at our components folder. In modern React projects, its
very common to have a folder which contains prebuilt components from a
[shadcn](https://ui.shadcn.com/) registry[^1]. These are usually found in
`üìÅ/components/ui`

[^1]:
    Most people think shadcn is a component library. While I suppose this is
    technically true, it only gives you half the picture. Shadcn is a
    [person](https://x.com/shadcn), who built a **standard** for building
    component libraries (naming the standard after himself). His personal
    component library built with this standard is very popular, and is why most
    people think it is just your everyday component library. But it is more than
    that. This distinction is important because I wish more people knew about
    this and used the standard to build their own component libaries.

<FolderView directory={folders.closerLookAtComponents} />

But this convention doesn't draw clear lines with regards to what code belongs
where. Does having some of the component files in `üìÅ/ui` mean that the others
**aren't** UI? Since its the components folder, that mean that all of this is
component code, right?

Typically, the answer to both of those questions is no.

Below is the first 30 lines of the sidebar component from official shadcn
registry. As we can see, it defines constants, a type, a context, and a hook
before we get to any component code.

```tsx
// components/ui/sidebar.tsx

const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "40rem";
const SIDEBAR_WIDTH_MOBILE = "100vw";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

export function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}
```

So then what should we do? Should we move all of this code into separate files
and put them in a new folder in `üìÅ/features`?

We could, sidebar isn't really a feature though. Looking over the
[documentation](https://ui.shadcn.com/docs/components/sidebar) for it, you can
see that its more like a collection of building blocks that we can put together
to build a sidebar _tailored to the specific needs_ of our app.

I think the sidebar code needs a new home, somewhere different than
`üìÅ/features`. Which brings us to our next topic: **_Atomic Design_**.

[Atomic Design](https://atomicdesign.bradfrost.com/table-of-contents/) is a book
written by [Brad Frost](https://bradfrost.com/). It outlines best practices for
building UI by defining 5 different categories: Atoms, Molecules, Organisms,
Templates, and Pages.

![Atomic Design Process](https://wr5t080c48.ufs.sh/f/Br1KpCv2wzAdP6d1F4069FNjRoqZEfamk1IlrK8PD4tOXTQL)

Brad wrote a [short article](https://bradfrost.com/blog/post/atomic-web-design/)
going over what defines each of these categories, but to summarize:

- **Atoms** are the smallest building blocks (buttons, labels, inputs)
- **Molecules** are composed of atoms (search bar, product card)
- **Organisms** are composed of molecules (masthead, product grid)
- **Templates** stitch organisms together
- **Pages** are specific instances of Templates

Despite being written over a decade ago[^2], this methodology aligns
surprisingly well with the way we're already building in React today.

[^2]:
    Brad and team worked on Atomic Design between 2013 and 2016, so at the time
    of writing this (December 2025) some of the content has not yet reached its
    10th birthday.

In the words of
[Katia Wheeler](https://medium.com/@wheeler.katia/thinking-about-react-atomically-608c865d2262):

> React, at its core, follows Atomic Design inherently by encouraging developers
> to keep components as simple and as broken down as possible. From this
> simplicity, we can create more complex components and containers of components
> to create the user interfaces of our applications.

I figured the best way to see how I truly feel about this mental model would be
to try it out myself. I decided to build the messaging app[^3] we outlined
earlier, strictly following the principles of Atomic Design.

[^3]:
    The result of this endeavour is the chatroom / discussion board thing in the
    sidebar on the left side of your screen. As I continued building and
    collected more opinions on this topic, I started writing them down.
    Eventually, I decided to make this whole thing into a blog website, with
    those opinions as the first post - and here we are.

Issues arose early on into the project. I found it difficult to decide whether
certain components should be classified as molecules or organisms. I also didn't
have many components that fit Brad's definition of an atom. This led me to the
realization that maybe the best route is to adopt the _sentiment_ of Atomic
Design, while adjusting the definitions to better fit the needs of a modern
React project.

To start, I decided not make any changes regarding _pages_ and _templates_. I
think the best course of action is to stick to whatever the meta-framework
you're building in prescribes. For example, `layout.tsx` and `page.tsx` in
Next.js are fairly analogous to templates and pages, so I think I'll just stick
with those primitives.

I also decided to get rid of organisms, leaving atoms and molecules as the units
to measure the complexity and size of components. My updated rules separating
them aren't perfectly aligned with their relationship in chemistry, but its
close enough that the analogy is still useful.

### Atoms

- Should be general purpose and reusable
- Contain any code that feels like it should belong together
- Multiple components per file is fine, encouraged even
- ‚úÖ **_Can_** be built with other atoms
- ‚ùå **_Cannot_** be built with molecules
- ex: button, sidebar, list, card, message

### Molecules

- Tailored to a specific use case, but possibly reusable across different areas
  of your app
- Can contain any code, but typically one component per file
- ‚úÖ **_Can_** be built with atoms
- ‚úÖ **_Can_** be built with other molecules
- ex: message list, search bar, admin sidebar, dashboard sidebar

This modified analogy allows components from shadcn to fit perfectly into the
category of atoms. You download atoms like button, sidebar, input, and then use
them to build the molecules that solve problems specific to your app.

Lets go ahead and move all of these shadcn components from `üìÅ/components/ui`
into a new folder: `üìÅ/atoms`

<FolderView directory={folders.moveShadcnComponentsToAtoms} />

Earlier we discussed the fact that the sidebar atom is quite large, containing
hundreds of lines of code. If you'd like to split it up, feel free to create a
sidebar folder and separate the code by type.

<FolderView directory={folders.sidebarAtomSplitUp} />

I find it helps to create an index file to clean up the imports across your
project:

```tsx
// atoms/sidebar/index.tsx

export * from "./sidebar-components";
export * from "./sidebar-context";
export * from "./sidebar-constants";
```

```tsx
// molecules/admin-sidebar.tsx

// ‚ùå import { Frame, Content, MenuItem } from "@/atoms/sidebar-components";
// ‚ùå import { Provider } from "@/atoms/sidebar/sidebar-context";

// ‚úÖ as long as your bundler can handle it.
import * as Sidebar from "@/atoms/sidebar.tsx";

function AdminSidebar() {
  <Sidebar.Provider>
    <Sidebar.Frame>
      <Sidebar.Content>
        <Sidebar.MenuItem>Dashboard</Sidebar.Button>
        <Sidebar.MenuItem>Analytics</Sidebar.Button>
        <Sidebar.MenuItem>Reports</Sidebar.Button>
      </Sidebar.Content>
    </Sidebar.Frame>
  </Sidebar.Provider>;
}

export default AdminSidebar;
```

But you should also build your own atoms. For the messaging app, I built
message, list, and scroll atoms. Each of these contains many components that
aren't terribly useful on their own. But when put together, it becomes trivial
to compose something like the molecule shown below.

```tsx
import * as List from "@/atoms/list";
import * as Message from "@/atoms/message";
import * as Scroll from "@/atoms/scroll";

function MessageList({ messages }: { messages: Message.Message[] }) {
  return (
    <Scroll.Frame>
      <Scroll.Container fade="sm">
        <List.Skeletons position="aboveContent" className="pt-4" />
        <List.Items className="pb-4">
          {messages.map((message) =>
            message.type === "user" ? (
              <UserMessage message={message} />
            ) : message.type === "assistant" ? (
              <AssistantMessage message={message} />
            ) : message.type === "system" ? (
              <SystemMessage message={message} />
            ) : null,
          )}
        </List.Items>
      </Scroll.Container>
      <Scroll.ScrollToBottomButton />
    </Scroll.Frame>
  );
}

export default MessageList;
```

UserMessage, AssistantMessage, and SystemMessage are also molecules, composed
with the Message atom.

```tsx
import * as Message from "@/atoms/message";

function UserMessage({ message }: { message: Message.Message }) {
  return (
    <Message.Provider message={message}>
      <Message.Frame className="mt-3">
        <div className="flex gap-3">
          <Message.PFP />
          <Message.Body>
            <Message.Header />
            <Message.Content />
            <Message.Reactions />
          </Message.Body>
        </div>
        <Message.Actions />
      </Message.Frame>
      <InlineComposer />
    </Message.Provider>
  );
}

export default UserMessage;
```

### Footnotes
