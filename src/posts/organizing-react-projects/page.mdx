import { basicProject } from "./folders";
import { FolderView } from "@/molecules/folder-view";

If you've worked in a modern React project before, then you've probably seen
something like this:

<FolderView directory={basicProject} />

```no_header

ğŸ“ components
â”œâ”€ ğŸ“ ui
â”‚  â”œâ”€ button.tsx
â”‚  â”œâ”€ input.tsx
â”‚  â””â”€ card.tsx
â”œâ”€ ğŸ“ pages
â”‚  â”œâ”€ home-page.tsx
â”‚  â””â”€ settings-page.tsx
â”œâ”€ footer.tsx
â””â”€ nav.tsx

ğŸ“ hooks
â”œâ”€ use-mobile.ts
â””â”€ use-is-client.ts

ğŸ“ types
â””â”€ index.ts

ğŸ“ lib
â”œâ”€ auth-client.ts
â””â”€ util.ts
```

Where files are split up across folders depending on what type of code lives
inside them. Components live with other components, hooks live with other hooks,
etc.

For a simple project like the one outlined above, this tends to work fine. But
as your codebase scales, you end up with _low feature cohesion_. Making changes
to one area of your app requires editing multiple files scattered far and wide
across different directories.

Lets take a look at a more complicated project: **a messaging app**.

```no_header
ğŸ“ components
â”œâ”€ ğŸ“ ui
â”‚  â”œâ”€ button.tsx
â”‚  â”œâ”€ input.tsx
â”‚  â”œâ”€ sidebar.tsx
â”‚  â””â”€ card.tsx
â”œâ”€ ğŸ“ pages
â”‚  â”œâ”€ home-page.tsx
â”‚  â”œâ”€ settings-page.tsx
â”‚  â”œâ”€ channel-page.tsx
â”‚  â”œâ”€ login-page.tsx
â”‚  â””â”€ thread-page.tsx
â”œâ”€ ğŸ“ auth
â”‚  â”œâ”€ sign-in-form.tsx
â”‚  â”œâ”€ sign-up-form.tsx
â”‚  â”œâ”€ sign-in-button.tsx
â”‚  â”œâ”€ sign-up-button.tsx
â”‚  â””â”€ sign-out-button.tsx
â”œâ”€ ğŸ“ messages
â”‚  â”œâ”€ user-message.tsx
â”‚  â”œâ”€ assistant-message.tsx
â”‚  â””â”€ system-message.tsx
â”œâ”€ ğŸ“ composer
â”‚  â”œâ”€ channel-composer.tsx
â”‚  â”œâ”€ edit-composer.tsx
â”‚  â””â”€ reply-composer.tsx
â”œâ”€ search-bar.tsx
â”œâ”€ message-list.tsx
â”œâ”€ header.tsx
â”œâ”€ footer.tsx
â””â”€ nav.tsx

ğŸ“ hooks
â”œâ”€ use-mobile.ts
â”œâ”€ use-message-actions.ts
â”œâ”€ use-debounced-input.ts
â”œâ”€ use-auth.ts
â”œâ”€ use-composer.ts
â”œâ”€ use-theme.ts
â””â”€ use-is-client.ts

ğŸ“ context
â”œâ”€ auth-context.tsx
â”œâ”€ message-context.tsx
â”œâ”€ search-context.tsx
â”œâ”€ channel-context.tsx
â””â”€ composer-context.tsx

ğŸ“ types
â”œâ”€ index.ts
â”œâ”€ composer-types.ts
â””â”€ message-types.ts

ğŸ“ lib
â”œâ”€ auth-client.ts
â””â”€ util.ts
```

As you can see, things are starting to get out of hand. `ğŸ“/components` is
growing much faster than the other directories, which makes sense. In React,
everything you can see on your screen is a component, so this folder is destined
to grow larger and larger as we add new features.

Earlier I mentioned that this way of building leads to low feature cohesion, and
now we can start to see why. If I'm overhauling messages, I may need to access
the message components, the message hook, the message context, and the message
type. These files all live in separate folders, with the only indication that
they are related being:

1. that they all have _message_ somewhere in their name
2. they likely import from each other.

So what should we do?

Maybe we make a new rule: if a feature has different types of code that
previously would have gone into separate folders, we house all of the files in a
new folder: `ğŸ“/features`

Lets try this, and see how things look.

```no_header
ğŸ“ components
â”œâ”€ ğŸ“ ui
â”‚  â”œâ”€ button.tsx
â”‚  â”œâ”€ input.tsx
â”‚  â”œâ”€ sidebar.tsx
â”‚  â””â”€ card.tsx
â”œâ”€ search-bar.tsx
â”œâ”€ header.tsx
â”œâ”€ footer.tsx
â””â”€ nav.tsx

ğŸ“ pages
â”œâ”€ home-page.tsx
â”œâ”€ settings-page.tsx
â”œâ”€ channel-page.tsx
â”œâ”€ login-page.tsx
â””â”€ thread-page.tsx

ğŸ“ features
â”œâ”€ ğŸ“ message
â”‚  â”œâ”€ ğŸ“ components
â”‚  â”‚  â”œâ”€ user-message.tsx
â”‚  â”‚  â”œâ”€ assistant-message.tsx
â”‚  â”‚  â”œâ”€ system-message.tsx
â”‚  â”‚  â””â”€ message-list.tsx
â”‚  â”œâ”€ ğŸ“ hooks
â”‚  â”‚  â””â”€ use-message-actions.ts
â”‚  â”œâ”€ ğŸ“ context
â”‚  â”‚  â””â”€ message-context.ts
â”‚  â””â”€ ğŸ“ types
â”‚     â””â”€ message-types.ts
â”œâ”€ ğŸ“ auth
â”‚  â”œâ”€ ğŸ“ components
â”‚  â”‚  â”œâ”€ sign-in-form.tsx
â”‚  â”‚  â”œâ”€ sign-up-form.tsx
â”‚  â”‚  â”œâ”€ sign-in-button.tsx
â”‚  â”‚  â”œâ”€ sign-up-button.tsx
â”‚  â”‚  â””â”€ sign-out-button.tsx
â”‚  â”œâ”€ ğŸ“ hooks
â”‚  â”‚  â””â”€ use-auth.ts
â”‚  â”œâ”€ ğŸ“ context
â”‚  â”‚  â””â”€ auth-context.ts
â”‚  â”œâ”€ ğŸ“ lib
â”‚  â”‚  â””â”€ auth-client.ts
â”‚  â””â”€ ğŸ“ types
â”‚     â””â”€ message-types.ts
â””â”€ ğŸ“ composer
   â”œâ”€ ğŸ“ components
   â”‚  â”œâ”€ channel-composer.tsx
   â”‚  â”œâ”€ edit-composer.tsx
   â”‚  â””â”€ reply-composer.tsx
   â”œâ”€ ğŸ“ hooks
   â”‚  â””â”€ use-composer.ts
   â”œâ”€ ğŸ“ context
   â”‚  â””â”€ composer-context.ts
   â””â”€ ğŸ“ types
      â””â”€ composer-types.ts

ğŸ“ hooks
â”œâ”€ use-mobile.ts
â”œâ”€ use-debounced-input.ts
â”œâ”€ use-theme.ts
â””â”€ use-is-client.ts

ğŸ“ context
â”œâ”€ search-context.tsx
â”œâ”€ channel-context.tsx

ğŸ“ types
â””â”€ index.ts

ğŸ“ lib
â””â”€ util.ts
```

Much better.

_note_: one thing I did without mentioning was move `ğŸ“/pages` up and out of
`ğŸ“/components`.

---

---

---

---

---

---

---

---

---

Where `ğŸ“/components/ui` contains prebuilt components from a library like
[shadcn](https://ui.shadcn.com/), and the components you build yourself live in
`ğŸ“/components`.

But this convention doesn't draw clear lines with regards to what code belongs
where. Does having some of the files in `ğŸ“/ui` mean that the others aren't UI?
Is the code in these files solely React components? We're in `ğŸ“/components`, so
does that mean that the code in these files is solely component code?

Typically the answer to both of those questions is no.

Below is the first 30 lines of the sidebar component from shadcn. As we can see,
it defines constants, a type, a context, and a hook before we get to any
component code.

```jsx
// sidebar.tsx

const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "40rem";
const SIDEBAR_WIDTH_MOBILE = "100vw";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

export function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}
```

So then what should we do? Should we move all of this code into separate files?

- sidebar-constants.ts
- sidebar-context.ts
- sidebar.tsx

Many projects do this, keeping designated folders for hooks, types, contexts,
and whatever else. While this may be useful for small pieces of code that are
truly just a hook or type, I don't think we should do this with our sidebar.
Having monolithic folders containing all of the hooks or types in our entire
codebase becomes increasingly more difficult to manage as our project grows. I
think we can do better.

So what then? Maybe a features folder?

We could create `ğŸ“/features/sidebar` and put the previously mentioned files in
there. This feels like a step in the right direction as it keeps related code
closer together. But how strictly will we follow this paradigm. Will we create
`sidebar-types.ts` even if we just have one single type definition? That feels a
bit unnecessary.

I'm starting to think maybe we had it right in the first place, colocating all
of our related code in one file. Maybe a better solution is to embrace that
mental model to a fuller extent, and rethink how we organize our projects from
the ground up.

But how?

While trying to find a good answer to this question, I stumbled upon
[Atomic Design](https://atomicdesign.bradfrost.com/table-of-contents/) by
[Brad Frost](https://bradfrost.com/). While most of it was written close to a
decade ago, I think the principles transfer over nicely to the the way we
currently build in React.

Brad outlines 5 different categories of UI: Atoms, Molecules, Organisms,
Templates, and Pages.

![Atomic Design Process](https://wr5t080c48.ufs.sh/f/Br1KpCv2wzAdP6d1F4069FNjRoqZEfamk1IlrK8PD4tOXTQL)

He gives an quick overview of what defines each of these categories in the
following [blog post](https://bradfrost.com/blog/post/atomic-web-design/), but
to summarize:

- Atoms are the smallest building blocks (buttons, labels, inputs)
- Molecules are composed of atoms (search bar)
- Organisms are composed of molecules (nav, footer, carousel)
- Templates stitch organisms together
- Pages are specific instances of Templates

At first glance I really resonated with this hierarchy. But as I tried to adopt
it this codebase, I found it difficult to draw lines between the 3 chemsitry
categories: _atoms, molecules, and organisms_.

What I ended up doing was getting rid of organisms, and just using atoms &
molecules. My rules dividing them aren't perfectly analagous to their
relationship in chemistry, but its close enough that the analogy holds.

### Atoms

- Broad, don't serve a specific purpose
- Used as blocks to build more niche components
- **_Can_** contain other atoms
- **_Cannot_** contain molecules
- ex: button, sidebar, list, card, message

### Molecules

- More specific, but broad enough that they're reusable across different pages
- **_Can_** contain other molecules
- ex: message list, search bar, variants (user message, assistant message,
  system message)

These rules have even helped me make better decisions about my code while
working on this post. While creating the code atom (seen below), I had imported
and used a molecule component named `CopyButton`. If this hadn't broken my atoms
& moleules rule, I wouldn't have thought twice about it.

```python
var foo = "bar"
```

But as we now know, atoms can't import molecules. So I thought on it. I realized
quickly that the only place I would use the `CopyButton` component is inside the
code block, so it made sense to have it just be another component in the `Code`
atom.

But won't this make our files unbearably long?

Yes, but I'd argue it shouldn't matter. In a top down framework like React, you
shouldn't be opening random files and trying to make sense of the code. You
should start at your page components and work your way down the tree to
understand how things are actually layered in your app. When you do this, cmd
clicking your way down the tree, it doesn't matter if your editor takes you to
line 10, or line 1000. You get exactly where you need.

```no_header
atoms/
â”œâ”€ message.tsx
â”œâ”€ composer.tsx
â”œâ”€ list.tsx
â””â”€ channel.tsx

molecules/
â”œâ”€ composers/
â”‚  â”œâ”€ channel-composer.tsx
â”‚  â”œâ”€ edit-composer.tsx
â”‚  â””â”€ reply-composer.tsx
â”œâ”€ messages/
â”‚  â”œâ”€ user-message.tsx
â”‚  â”œâ”€ assistant-message.tsx
â”‚  â””â”€ system-message.tsx
â”œâ”€ message-list.tsx
â””â”€ channel-list.tsx

templates/
â”œâ”€ centered.tsx
â””â”€ two-column.tsx

pages/
â”œâ”€ channel-page.tsx
â”œâ”€ thread-page.tsx
â”œâ”€ home-page.tsx
â””â”€ settings-page.tsx
```
