import { FolderView } from "@/features/directory/molecules/folder-view";
import * as folders from "./folders";

If you've worked in a modern React project before, then you've probably seen
something like this:

<FolderView directory={folders.basicProject} />

Where files are split up across folders depending on what type of code lives
inside them. Components live with other components, hooks live with other hooks,
etc.

For a simple project like the one outlined above, this tends to work fine. But
as your codebase scales, you end up with _low feature cohesion_. Making changes
to one area of your app requires editing multiple files scattered far and wide
across different directories.

Lets take a look at a more complicated project: **a messaging app**.

<FolderView directory={folders.messagingAppFirstIteration} />

As you can see, things are starting to get out of hand. `üìÅ/components` is
growing much faster than the other directories, which makes sense. In React,
everything you can see on your screen is a component, so this folder is destined
to grow quickly.

Earlier I mentioned that this way of building leads to low feature cohesion, and
now we can start to see why. If you want to overhaul the code for messages, you
may need to access the message components, the message hook, the message
context, and the message type. These files all live in separate folders, with
the only indication that they are related being that:

1. they all have _message_ somewhere in their name
2. they likely import from each other.

So what should we do?

Maybe we make a new rule: if a feature has different types of code that
previously would have been spread across multiple folders, we house all of the
files in a new folder: `üìÅ/features`

Lets try this, and see how things look.

<FolderView directory={folders.messagingAppSecondIteration} />

This feels much better. Now when we want to make changes to messages, all of the
code is in one place: `üìÅ/features/message`

So is that it? Are we done?

We could be. You can get far with our new layout. Keeping code for related
features close together will make things much easier to manage as we scale our
app.

But I think we can do even better.

Lets take a closer look at our components folder. In modern React projects, its
very common to have a folder named `üìÅ/components/ui` which contains prebuilt
components from a [shadcn](https://ui.shadcn.com/) registry.

<FolderView directory={folders.closerLookAtComponents} />

But this convention doesn't draw clear lines with regards to what code belongs
where. Is the code in this folder solely React components? Does having some of
our component files in `üìÅ/ui` mean that the others aren't UI?

Typically the answer to both of those questions is no.

Below is the first 30 lines of the sidebar component from official shadcn
registry. As we can see, it defines constants, a type, a context, and a hook
before we get to any component code.

```jsx
// components/ui/sidebar.tsx

const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "40rem";
const SIDEBAR_WIDTH_MOBILE = "100vw";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

export function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}
```

So then what should we do? Should we move all of this code into separate files?
Should we then put them in a new folder in `üìÅ/features`?

I say: no.

Let me explain. I think moving code into separate files can be helpful if we
expect to expand on the feature down the road. For example: as our app grows and
we add new features, there's a good chance we'll be making changes and
refactoring messages along the way. I think separating the code out makes this
easier, as you don't have to swim through one monolithic file to find what
you're looking for.

But for something like the sidebar, I think its actually quite nice to have all
of the code colocated in one file. While we may need to make some changes to
adapt it to our project, chances are we won't be making changes to it often.

I think this file is fine just the way it is. I think it just needs a new home.

Enter: [Atomic Design](https://atomicdesign.bradfrost.com/table-of-contents/).

Atomic design is a book written by [Brad Frost](https://bradfrost.com/). Despite
being mostly written before React's mass adoption (book was completed in 2016),
it aligns surprisingly well with the way we built in React today.

In his book, Brad outlines 5 different categories of UI: Atoms, Molecules,
Organisms, Templates, and Pages.

![Atomic Design Process](https://wr5t080c48.ufs.sh/f/Br1KpCv2wzAdP6d1F4069FNjRoqZEfamk1IlrK8PD4tOXTQL)

He gives an quick overview of what defines each of these categories in the
following [blog post](https://bradfrost.com/blog/post/atomic-web-design/), but
to summarize:

- Atoms are the smallest building blocks (buttons, labels, inputs)
- Molecules are composed of atoms (search bar)
- Organisms are composed of molecules (nav, footer, carousel)
- Templates stitch organisms together
- Pages are specific instances of Templates

As I read along, I really resonated with this hierarchy. It feels like the way
most of us are already building in React, it just draws some good lines for how
big to make different types of components.

In the words of
[Katia Wheeler](https://medium.com/@wheeler.katia/thinking-about-react-atomically-608c865d2262):

> React, at its core, follows Atomic Design inherently by encouraging developers
> to keep components as simple and as broken down as possible. From this
> simplicity, we can create more complex components and containers of components
> to create the user interfaces of our applications.

While I did find myself agreeing with Brad on most things, I ran into some
issues trying to strictly adopt these patterns into my codebase. My main issue
was drawing the lines between molecules and organisms.

What I ended up doing was getting rid of organisms, and just using atoms &
molecules. My rules dividing them aren't perfectly aligned with their
relationship in chemistry, but its close enough that the analogy holds.

### Atoms

- Broad, don't serve a specific purpose
- Used as blocks to build more components with a more specific purpose
- **_Can_** contain other atoms
- **_Cannot_** contain molecules
- ex: button, sidebar, list, card, message

### Molecules

- More specific, but broad enough that they're reusable across different areas
- **_Can_** contain atoms
- **_Can_** contain other molecules
- ex: message list, search bar

These rules have even helped me make better decisions about my code while
working on this post. While creating the code atom (seen below), I had imported
and used a molecule component named `CopyButton`. If this hadn't broken my atoms
& moleules rule, I wouldn't have thought twice about it.

```python
var foo = "bar"
```

But as we now know, atoms can't import molecules. So I thought on it. I realized
quickly that the only place I would use the `CopyButton` component is inside the
code block, so it made sense to have it just be another component in the `Code`
atom.

But won't this make our files unbearably long?

Yes, but I'd argue it shouldn't matter. In a top down framework like React, you
shouldn't be opening random files and trying to make sense of the code. You
should start at your page components and work your way down the tree to
understand how things are actually layered in your app. When you do this, cmd
clicking your way down the tree, it doesn't matter if your editor takes you to
line 10, or line 1000. You get exactly where you need.
