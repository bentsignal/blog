import { FolderView } from "@/features/directory/molecules/folder-view";
import * as folders from "./folders";
import { SearchBar, SearchContext } from "@/molecules/search-bar";

If you've worked in a modern React project before, then you've probably seen
something like this:

<FolderView directory={folders.basicProject} />

Where files are split up across folders depending on what type of code lives
inside them. Components live with other components, hooks live with other hooks,
etc.

For a simple project like the one outlined above, this tends to work fine. But
as your codebase scales, you end up with _low feature cohesion_. Making changes
to one area of your app requires editing multiple files scattered far and wide
across different directories.

To see this in action, lets take a look at a project with a bit more complexity:
**a messaging app**.

<FolderView directory={folders.messagingAppFirstIteration} />

I mentioned that this way of building leads to low feature cohesion, and now we
can start to see why. If you want to overhaul messages, you may need to access
components, hooks, contexts, and types. This code lives in separate files in
separate folders, with the only indication that they are related being that:

1. they all have _message_ somewhere in their name
2. they likely import from each other.

So what should we do?

Lets make a new rule: if a feature has different types of code that previously
would have been spread across multiple folders, we create a dedicated folder for
that feature. So for example, all our code for messages would now live in
`üìÅ/features/messages`

Lets try this, and see how things look.

<FolderView directory={folders.messagingAppSecondIteration} />

This feels much better. Now when you want to make changes to messages, all of
the code is in one place: `üìÅ/features/messages`

So is that it? Are we done?

We could be. This pattern can take you far. Keeping code for related features
close together will make things much easier to manage as you scale your app.

But I think we can do even better.

Lets take a closer look at our components folder. In modern React projects, its
very common to have a folder which contains prebuilt components from a
[shadcn](https://ui.shadcn.com/) registry[^1]. These are usually found in
`üìÅ/components/ui`

[^1]:
    Most people think shadcn is a component library. While I suppose this is
    technically true, it only gives you half the picture. Shadcn is a
    [person](https://x.com/shadcn), who build a **standard** for building
    component libraries (naming the standard after himself). His personal
    component library built with this standard is very popular, and is why most
    people think it is just your everyday component library. But it is more than
    that. This distinction is important because I wish more people knew about
    this and used the standard to build their own component libaries.

<FolderView directory={folders.closerLookAtComponents} />

But this convention doesn't draw clear lines with regards to what code belongs
where. Does having some of the component files in `üìÅ/ui` mean that the others
**aren't** UI? Since its the components folder, that mean that all of this is
component code, right?

Typically, the answer to both of those questions is no.

Below is the first 30 lines of the sidebar component from official shadcn
registry. As we can see, it defines constants, a type, a context, and a hook
before we get to any component code.

```jsx
// components/ui/sidebar.tsx

const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "40rem";
const SIDEBAR_WIDTH_MOBILE = "100vw";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

export function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}
```

So then what should we do? Should we move all of this code into separate files
and put them in a new folder in `üìÅ/features`?

We could, but sidebar isn't really a feature though. Looking over the
[documentation](https://ui.shadcn.com/docs/components/sidebar) for it, you can
see that its more like a collection of building blocks that we can put together
to build a sidebar tailored to the specific needs of our app.

I think the sidebar code needs a new home, but somewhere different than
`üìÅ/features`. This brings us to our next topic: **_Atomic Design_**.

[Atomic Design](https://atomicdesign.bradfrost.com/table-of-contents/) is a book
written by [Brad Frost](https://bradfrost.com/). It outlines best practices for
building UI by defining 5 different categories: Atoms, Molecules, Organisms,
Templates, and Pages.

![Atomic Design Process](https://wr5t080c48.ufs.sh/f/Br1KpCv2wzAdP6d1F4069FNjRoqZEfamk1IlrK8PD4tOXTQL)

Brad wrote a [short article](https://bradfrost.com/blog/post/atomic-web-design/)
going over what defines each of these categories, but to summarize:

- **Atoms** are the smallest building blocks (buttons, labels, inputs)
- **Molecules** are composed of atoms (search bar, product card)
- **Organisms** are composed of molecules (masthead, product grid)
- **Templates** stitch organisms together
- **Pages** are specific instances of Templates

Despite being written over a decade ago[^2], this methodology aligns
surprisingly well with the way we're already building in React today.

[^2]:
    Brad and team worked on Atomic Design between 2013 and 2016, so at the time
    of writing this (December 2025) some of the content has not yet reached its
    10th birthday.

In the words of
[Katia Wheeler](https://medium.com/@wheeler.katia/thinking-about-react-atomically-608c865d2262):

> React, at its core, follows Atomic Design inherently by encouraging developers
> to keep components as simple and as broken down as possible. From this
> simplicity, we can create more complex components and containers of components
> to create the user interfaces of our applications.

After reading through the book, I set off to build something with this new
mental model. I figured the best way to see how I truly feel about it would be
to try it out myself. I decided to build a simple messaging app[^3], strictly
following the principles of Atomic Design.

[^3]:
    The result of this endeavour is the chatroom / discussion board thing in the
    sidebar on the left side of your screen. As I continued building and
    collected more opinions on the matter, I started writing them down.
    Eventually, I decided to make this whole thing into a blog website, with
    those opinions as the first post - and here we are.

Issues began to arise shortly after beginning the project. I found it difficult
to decide whether certain components should be classified as molecules or
organisms. I also didn't have many components that fit Brad's definition of an
atom. This led me to the realization that maybe the best route is to adopt the
_sentiment_ of atomic design, while adjusting the definitions to better fit the
needs of a modern React project.

My first modification was to get rid of organisms, and use atoms and molecules
as the units to measure components. My rules dividing them aren't perfectly
aligned with their relationship in chemistry, but its close enough that the
analogy holds.

### Atoms

- Can contain components, types, hooks, context, constants, and any other code
  that feels like it should belong together
- Can contain potentially dozens of components that can be used as blocks to
  build components with a more specific purpose
- ‚úÖ **_Can_** contain other atoms
- ‚ùå **_Cannot_** contain molecules
- ex: button, sidebar, list, card, message

### Molecules

- More specific, but broad enough that they're reusable
- ‚úÖ **_Can_** contain atoms
- ‚úÖ **_Can_** contain other molecules
- ex: message list, search bar

This modified analogy allows fits very well with the current practice of
building around component libraries. Everything you download from the shadcn
registry can be thought of as an atom. These atoms are then used to build the
molecules that serve a more specific purpose while still being reusable.

For example, lets consider a search bar molecule.

You might construct it using the button and input atoms. It has the specific
purpose of letting your user search for something, but it can still be used in
multiple places throughout your app.

An important distinction I included in my definitions is that atoms **_cannot_**
use molecules.

So how does this all tie together?

---

These rules have even helped me make better decisions about my code while
working on this post. While creating the code atom (seen below), I had imported
and used a molecule component named `CopyButton`. If this hadn't broken my atoms
& moleules rule, I wouldn't have thought twice about it.

```python
var foo = "bar"
```

But as we now know, atoms can't import molecules. So I thought on it. I realized
quickly that the only place I would use the `CopyButton` component is inside the
code block, so it made sense to have it just be another component in the `Code`
atom.

But won't this make our files unbearably long?

Yes, but I'd argue it shouldn't matter. In a top down framework like React, you
shouldn't be opening random files and trying to make sense of the code. You
should start at your page components and work your way down the tree to
understand how things are actually layered in your app. When you do this, cmd
clicking your way down the tree, it doesn't matter if your editor takes you to
line 10, or line 1000. You get exactly where you need.

### Footnotes
